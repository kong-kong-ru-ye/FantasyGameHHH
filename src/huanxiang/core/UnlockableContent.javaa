p




this.eat(); // this 调用自己的方法

super.eat(); // super 调用父类方法






ublic enum TrafficLamp {

//由于枚举值默认式public,final,static,按照规范变量名全部大写

//正是由于枚举值的这一特性，为我们实现单列提供了一种很好的方案

//注意此时的枚举值都是引用，相当于public static final TrafficLamp RED = new  //TrafficLamp();

RED{//匿名内部类，RED指向继承了TrafficLamp的子类对象，以下同理

public TrafficLamp state(){

try {

Thread.sleep(30000);

} catch (InterruptedException e) {

e.printStackTrace();

}

return GREEN;

}

},GREEN{

public TrafficLamp state(){

try {

Thread.sleep(60000);

} catch (InterruptedException e) {

e.printStackTrace();

}

return YELLOW;

}

},YELLOW{

public TrafficLamp state(){

try {

Thread.sleep(3000);

} catch (InterruptedException e) {

e.printStackTrace();

}

return RED;

}

};

private TrafficLamp(){}

private TrafficLamp(int time){

}

public abstract TrafficLamp state();

//简单的模拟

public static void main(String[] args) {

Boolean flag=true;

While(flag){

RED.state().state().state();

}

}

 

******************************************************************************